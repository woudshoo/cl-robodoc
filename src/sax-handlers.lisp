(in-package :cl-robodoc)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Handler to handl the "uml" tag and replace the "uml" tag content
;;; with the svg generated by plantuml.
;;;
;;; Of course it would be preferable to use the pipe interface of pantuml
;;; but that seems not to work with sbcl on windows.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(defun write-gnuplot-file (out-file)
  (let ((file-name "/tmp/gpcommand"))
    (with-open-file (s file-name :direction :output :if-exists :supersede)
		    (format s "set terminal svg~%")
		    (format s "set output '~A'~%" out-file))
    file-name))

(defparameter *transcribe-handlers* 
  `(("uml" :includer include-xml-file 
	   :converter ,(lambda (in-name out-name)
			       (external-program:run *java-cmd*
				`("-Djava.awt.headless=true" "-jar" ,*uml-jar* "-tsvg" ,in-name))
			       out-name))
    ("gnuplot" :includer include-xml-file 
	       :converter ,(lambda (in-name out-name)
				   (external-program:run *gnuplot-cmd* 
							 `(,(write-gnuplot-file out-name) 
							   ,in-name))
				   out-name))
    ("ccode" :includer include-xml-file 
	     :converter ,(lambda (in-name out-name)
			   (with-open-file (s out-name :direction :output)
					   (colorize:colorize-file-to-stream :c++ in-name s :wrap nil))
				 out-name))))

(defclass uml-transcribe-handler (cxml:broadcast-handler)
  ((collect-file-name :initform nil :accessor collect-file-name)
   (collect-stream :initform nil :accessor collect-stream)))

(defmethod pick-random-name ((handler uml-transcribe-handler))
  (setf (collect-file-name handler)
	(parse-namestring (format nil 
				  "/tmp/~A" (random (expt 10 10))))))

(defmethod uml-file-name ((handler uml-transcribe-handler))
  (merge-pathnames (make-pathname :type "uml") 
		   (collect-file-name handler)))

(defmethod svg-file-name ((handler uml-transcribe-handler))
  (merge-pathnames (make-pathname :type "svg") 
		   (collect-file-name handler)))

(defmethod sax:start-element ((handler uml-transcribe-handler) namespace-uri local-name qname attributes)
  (declare (ignore namespace-uri local-name attributes))
  (if (assoc-value *transcribe-handlers* qname :test #'equal)
    (with-slots (collect-stream) handler 
      (assert (not collect-stream))
      (pick-random-name handler)
      (setf (collect-stream handler) (open (uml-file-name handler)
					   :direction :output 
					   :if-exists :overwrite 
					   :if-does-not-exist :create
					   :external-format :utf-8)))
    (call-next-method)))

(defmethod sax:characters ((handler uml-transcribe-handler) (data string))
  (if (collect-stream handler)
    (write-string data (collect-stream handler))
    (call-next-method)))

(defmethod sax:end-element ((handler uml-transcribe-handler) namespace-uri local-name qname)
  (declare (ignore namespace-uri local-name))
  (if-let (convertor (assoc-value *transcribe-handlers* qname :test #'equal))
      (progn
	(close (collect-stream handler))
	(setf (collect-stream handler) nil)
	(funcall (getf convertor :includer) handler 
			  (funcall (getf  convertor :converter) 
				   (namestring (uml-file-name handler))
				   (namestring (svg-file-name handler))))

#+nil	(delete-file (uml-file-name handler))
#+nil	(delete-file (svg-file-name handler)))
      (call-next-method)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Filter 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defclass filter-attributes-handler (cxml:broadcast-handler)
  ((attributes-to-remove :initform nil :initarg :to-remove :reader attributes-to-remove)))

(defmethod sax:start-element ((handler filter-attributes-handler) namespace-uri local-name qname attributes)
  (call-next-method handler namespace-uri local-name qname
		    (remove-if (lambda (attribute) (member (sax:attribute-qname attribute)
							   (attributes-to-remove handler) :test #'equal))
			       attributes)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Handler which strips the start and end document events
;; This handler is used for the include-xml-file function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defclass no-start-end-handler (cxml:broadcast-handler)
  ()
  (:documentation "Handler which passes an sax stream through unmodified, except
that the start and end document events are supressed.  
This is usefull to include one sax stream into another. 
The stream being included should not have the start and end document. 
If they do, the end-document of the included stream will end the complete document."))

(defmethod sax:start-document ((handler no-start-end-handler))
  nil)

(defmethod sax:end-document ((handler no-start-end-handler))
  nil)


(defun include-xml-file (handler file-name)
  "Includes the content of the xml file file-name, into the
output sax stream hander."
  (flet ((resolver (public sysid)
	   (declare (ignore public sysid))
	   (flexi-streams:make-in-memory-input-stream nil)))
    (cxml:parse-file file-name 
		     (make-instance 'no-start-end-handler
				    :handlers (list (make-instance 'filter-attributes-handler
								   :to-remove '("textLength" "lengthAdjust")
								   :handlers  (list handler))))
		     :entity-resolver #'resolver)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Linkify handler
;;;
;;;
;;; Add links to certain words
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(defclass linkify-handler (cxml:broadcast-handler)
  ((words :initform (fset:set) :initarg :words :accessor words)
   (exclude-words :initform (fset:set) :initarg :exclude-words :accessor exclude-words)
   (link-ref-stack :initform (list "href") :accessor link-ref-stack))
  (:documentation "Sax handler which insert links into a sax stream.
It will scan the sax:characters stream for occurances of words listed in the words slot.
If a word is found, an <a> element is inserted.  The <a> element will have normally
a 'href' attribute with value 'word.hmtl'.  

It will use attribute 'xlink:href' if the characters occur inside an svg element.

Note that if the word is also found in the exclude-word slot it will NOT be linkified.

TO IMPROVE:  
- It now also removes #XC characters, this should be done in a whitspace cleaner
- If the sax:characters call is broken up and a word spans two invocations of sax:charaters, 
  this word is not recognized.
- It should allow more flexibility in creating the target, instead of appending the .html suffix."))


(defmethod sax:start-element ((handler linkify-handler) namespace-uri local-name qname attributes)
  (declare (ignore namespace-uri local-name attributes))
  (when (equal "svg" qname)
    (push "xlink:href" (link-ref-stack handler)))
  (call-next-method))

(defmethod sax:characters ((handler linkify-handler) (data string))

  (let ((start 0)
	(processed-until 0))
    (setf data (remove #XC data :key #'char-code)) ;;; this should move to whitespace cleanup code
    (flet ((flush (until)
	     (when (> until processed-until)
	       (call-next-method handler (subseq data processed-until until))
	       (setf processed-until until))))
      (loop 
	 :while start
	 :do
	 (multiple-value-bind (match-start match-end) 
	     (cl-ppcre:scan "\\w+" data :start start)
	   (when (and match-start match-end)
	     (let ((key (subseq data  match-start match-end)))
	       (when (and (fset:lookup (words handler) key)
			  (not (fset:lookup (exclude-words handler) key)))
		 ;; Ok we need to replace
		 (flush match-start)
		 (sax:start-element handler nil nil "a" 
				    (list (sax:make-attribute :qname (car (link-ref-stack handler))
							      :value (format nil "~A.html" key))))
		 (flush match-end)
		 (sax:end-element handler nil nil "a"))))
	   (setf start match-end)))
      (flush (length data)))))

(defmethod sax:end-element ((handler linkify-handler) namespace-uri local-name qname)
  (declare (ignore namespace-uri local-name))
  (when (equal "svg" qname)
    (pop (link-ref-stack handler)))
  (call-next-method))


